import { access, chmod, readFile, writeFile } from 'node:fs/promises';
import { basename, delimiter, dirname } from 'node:path';

import { runCommand } from './service-manager-command.js';

export const serviceEnvFilename = 'service.env';
export const serviceEnvSnapshotFilename = 'service.env.snapshot';
export const nodeEnvFileIfExistsVersionRequirement = '>=20.19.0 <21 || >=22.9.0';

const serviceEnvironmentExplicitKeys = new Set([
  'HOME',
  'SHELL',
  'LANG',
  'LC_ALL',
  'LC_CTYPE',
  'LC_MESSAGES',
  'TMPDIR',
  'HOMEBREW_PREFIX',
  'HOMEBREW_CELLAR',
  'HOMEBREW_REPOSITORY',
  'ASDF_DIR',
  'ASDF_DATA_DIR',
  'MISE_DATA_DIR',
  'MISE_CONFIG_DIR',
  'MISE_CACHE_DIR',
  'MISE_INSTALL_PATH',
  'UV_CACHE_DIR',
  'UV_TOOL_BIN_DIR',
  'UV_PYTHON_INSTALL_DIR',
  'PNPM_HOME',
  'NVM_DIR',
  'VOLTA_HOME',
  'PYENV_ROOT',
  'RBENV_ROOT',
  'CARGO_HOME',
  'RUSTUP_HOME',
  'GOPATH',
  'GOROOT',
  'JAVA_HOME',
  'PIPX_HOME',
  'PIPX_BIN_DIR',
  'POETRY_HOME',
  'FNM_DIR',
]);

const serviceEnvironmentPrefixes = [
  'LC_',
  'HOMEBREW_',
  'MISE_',
  'ASDF_',
  'UV_',
  'PNPM_',
  'NPM_CONFIG_',
  'NVM_',
  'VOLTA_',
  'PYENV_',
  'RBENV_',
  'CARGO_',
  'RUSTUP_',
  'GOENV_',
  'PIPX_',
  'POETRY_',
  'FNM_',
];

const shellEnvironmentCaptureTimeoutMs = 5000;

export async function ensureServiceEnvironmentFiles(options: {
  serviceEnvPath: string;
  serviceEnvSnapshotPath: string;
  nodePath: string;
  telegramBotToken?: string;
}): Promise<void> {
  const shellPath = resolveUserShellPath();
  const shellEnvironment = (await captureShellEnvironment(shellPath)) ?? process.env;
  const snapshotEnvironment = buildServiceEnvironmentSnapshot(shellEnvironment, options.nodePath);

  const snapshotContent = renderEnvironmentFile({
    header: [
      '# jagc managed file',
      '# Regenerated by: jagc install',
      '# Captured from your login shell for package-manager/tooling PATH parity.',
      '# Edit service.env for custom overrides; this file may be replaced.',
    ],
    variables: snapshotEnvironment,
  });

  await writeFile(options.serviceEnvSnapshotPath, snapshotContent, { mode: 0o600 });
  await chmod(options.serviceEnvSnapshotPath, 0o600);

  if (!(await fileExists(options.serviceEnvPath))) {
    await writeFile(options.serviceEnvPath, renderDefaultUserServiceEnvironment(), { mode: 0o600 });
  }

  const serviceEnvContent = await readFile(options.serviceEnvPath, 'utf8');
  const updatedServiceEnvContent = applyServiceInstallEnvironmentOverrides(serviceEnvContent, {
    telegramBotToken: options.telegramBotToken,
  });

  if (updatedServiceEnvContent !== serviceEnvContent) {
    await writeFile(options.serviceEnvPath, updatedServiceEnvContent, { mode: 0o600 });
  }

  await chmod(options.serviceEnvPath, 0o600);
}

export function buildServiceEnvironmentSnapshot(shellEnv: NodeJS.ProcessEnv, nodePath: string): Record<string, string> {
  const snapshot: Record<string, string> = {};

  const shellPath = shellEnv.PATH;
  snapshot.PATH = mergePath(shellPath, nodePath);

  for (const [key, value] of Object.entries(shellEnv)) {
    if (!value) {
      continue;
    }

    if (!shouldCaptureServiceEnvironmentKey(key)) {
      continue;
    }

    snapshot[key] = value;
  }

  return sortEnvironmentEntries(snapshot);
}

export function applyServiceInstallEnvironmentOverrides(
  content: string,
  options: { telegramBotToken?: string },
): string {
  let updatedContent = content;

  if (options.telegramBotToken) {
    updatedContent = upsertEnvironmentFileVariable(updatedContent, 'JAGC_TELEGRAM_BOT_TOKEN', options.telegramBotToken);
  }

  return updatedContent;
}

export function upsertEnvironmentFileVariable(content: string, key: string, value: string): string {
  const normalizedLines = content.replaceAll('\r\n', '\n').split('\n');
  if (normalizedLines.at(-1) === '') {
    normalizedLines.pop();
  }

  const entry = `${key}=${formatEnvFileValue(value)}`;
  let replaced = false;

  const updatedLines = normalizedLines.map((line) => {
    const match = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=/);
    if (!match || match[1] !== key) {
      return line;
    }

    replaced = true;
    return entry;
  });

  if (!replaced) {
    updatedLines.push(entry);
  }

  return `${updatedLines.join('\n')}\n`;
}

export function renderDefaultUserServiceEnvironment(): string {
  return [
    '# jagc user overrides',
    '# Loaded after service.env.snapshot; values here win.',
    '#',
    '# Supported format: KEY=value (dotenv style).',
    '# Node does not expand shell vars here; use absolute paths.',
    '#',
    '# Example tool paths (uncomment + adjust):',
    '# PATH=/Users/you/.local/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin',
    '# UV_TOOL_BIN_DIR=/Users/you/.local/share/uv/tools/bin',
    '# PNPM_HOME=/Users/you/Library/pnpm',
    '# ASDF_DATA_DIR=/Users/you/.asdf',
    '# MISE_DATA_DIR=/Users/you/.local/share/mise',
    '',
  ].join('\n');
}

function mergePath(shellPath: string | undefined, nodePath: string): string {
  const entries = [
    dirname(nodePath),
    ...(shellPath ? shellPath.split(delimiter) : []),
    ...buildLaunchdPath(nodePath).split(delimiter),
  ];

  const seen = new Set<string>();

  return entries
    .map((entry) => entry.trim())
    .filter((entry) => {
      if (entry.length === 0 || seen.has(entry)) {
        return false;
      }

      seen.add(entry);
      return true;
    })
    .join(delimiter);
}

function buildLaunchdPath(nodePath: string): string {
  const candidates = [dirname(nodePath), '/opt/homebrew/bin', '/usr/local/bin', '/usr/bin', '/bin'];
  const seen = new Set<string>();

  return candidates
    .filter((entry) => {
      if (seen.has(entry)) {
        return false;
      }

      seen.add(entry);
      return true;
    })
    .join(':');
}

function sortEnvironmentEntries(entries: Record<string, string>): Record<string, string> {
  const sorted = Object.entries(entries).sort(([left], [right]) => left.localeCompare(right));
  return Object.fromEntries(sorted);
}

function shouldCaptureServiceEnvironmentKey(key: string): boolean {
  if (serviceEnvironmentExplicitKeys.has(key)) {
    return true;
  }

  return serviceEnvironmentPrefixes.some((prefix) => key.startsWith(prefix));
}

function renderEnvironmentFile(options: { header: string[]; variables: Record<string, string> }): string {
  const lines = [...options.header, ''];

  for (const [key, value] of Object.entries(options.variables)) {
    lines.push(`${key}=${formatEnvFileValue(value)}`);
  }

  return `${lines.join('\n')}\n`;
}

function formatEnvFileValue(value: string): string {
  if (/^[A-Za-z0-9_./:@%+,-]+$/.test(value)) {
    return value;
  }

  return JSON.stringify(value);
}

async function captureShellEnvironment(shellPath: string): Promise<NodeJS.ProcessEnv | null> {
  for (const args of shellCaptureArgs(shellPath)) {
    const result = await runCommand(shellPath, args, {
      allowFailure: true,
      trimOutput: false,
      timeoutMs: shellEnvironmentCaptureTimeoutMs,
      env: {
        ...process.env,
        SHELL: shellPath,
      },
    });

    if (result.code !== 0) {
      continue;
    }

    const parsed = parseNullDelimitedEnvironment(result.stdout);
    if (Object.keys(parsed).length > 0) {
      return parsed;
    }
  }

  return null;
}

function shellCaptureArgs(shellPath: string): string[][] {
  const shellName = basename(shellPath);

  if (shellName === 'bash' || shellName === 'zsh') {
    return [
      ['-ilc', 'env -0'],
      ['-lc', 'env -0'],
    ];
  }

  return [['-lc', 'env -0']];
}

function parseNullDelimitedEnvironment(output: string): NodeJS.ProcessEnv {
  const env: NodeJS.ProcessEnv = {};

  for (const entry of output.split('\u0000')) {
    const separatorIndex = entry.indexOf('=');
    if (separatorIndex <= 0) {
      continue;
    }

    const key = entry.slice(0, separatorIndex).trim();
    const value = entry.slice(separatorIndex + 1);

    if (!isValidEnvironmentKey(key)) {
      continue;
    }

    env[key] = value;
  }

  return env;
}

function isValidEnvironmentKey(key: string): boolean {
  return /^[A-Za-z_][A-Za-z0-9_]*$/.test(key);
}

function resolveUserShellPath(): string {
  const shell = process.env.SHELL?.trim();
  if (shell?.startsWith('/')) {
    return shell;
  }

  return '/bin/bash';
}

async function fileExists(path: string): Promise<boolean> {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}
